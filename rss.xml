<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Haichao Blog]]></title><description><![CDATA[The place where Haichao writes when he want.]]></description><link>https://www.haichaozhu.com/</link><generator>RSS for Node</generator><lastBuildDate>Thu, 20 Jun 2019 08:59:57 GMT</lastBuildDate><item><title><![CDATA[BTC as Money Anchor]]></title><description><![CDATA[October 2018, Satoshi Nakamoto published the Bitcoin whitepaper. In the paper he addresses the Bitcoin system as a peer to peer electronic…]]></description><link>https://www.haichaozhu.com//btc-as-money-anchor/</link><guid isPermaLink="false">https://www.haichaozhu.com//btc-as-money-anchor/</guid><pubDate>Thu, 16 May 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;October 2018, Satoshi Nakamoto published the Bitcoin whitepaper. In the paper he addresses the Bitcoin system as a peer to peer electronic cash system. In another word, Satoshi wanted it to be a payment system that use the token BTC as Medium of Exchange and Unit of Account. In another word, a new money.&lt;/p&gt;
&lt;h2&gt;BTC as Money and Gold&lt;/h2&gt;
&lt;p&gt;Soon after its release, pioneers realized that being money is actually not feasible, as BTC has a predefined supply schedule that nobody can alter. Money is not just printed papers. The supply of money should be dynamically adjusted according to the demand of money, which is determined by the growth of the economics system that this money is serving. E.g. the supply of US dollars should be increased according to the growth of US economics. If US’s GDP grows for 10%, then the supply of US dollars should be increased for 10% accordingly. Otherwise we will face the money deflation problem that we encountered &lt;a href=&quot;https://en.wikipedia.org/wiki/Deflation#Historical_examples&quot;&gt;in the history for many times&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;Besides of this reason, from a high level perspective, maintaining a money has a cost, which is hard to be covered with only the public blockchain system due to is decentralization nature.&lt;/p&gt;
&lt;p&gt;So, BTC can not be money.&lt;/p&gt;
&lt;p&gt;Gold is commonly regarded as a value preservation asset (aka store-of-value). It has a limited supply on this planet and cannot be artificially fabricated. &lt;/p&gt;
&lt;p&gt;You may find these properties sounds familiar. BTC has all these nice properties as well and even better. Gold requires special techniques and environment to custody, which is a huge cost for individuals to posses it as investment asset. BTC is a digital formed asset, which means it is almost imperishable. It surely costs some electricity, but comparing to gold it enables self-custodian that you do not have to turn to third party institutions for custody service. &lt;/p&gt;
&lt;p&gt;So, BTC can be the new gold.&lt;/p&gt;
&lt;h2&gt;BTC as Money Anchor&lt;/h2&gt;
&lt;p&gt;The fiats today are mostly credit based currencies, which means they are basically backed by national credit. The basic process of creating money is that first the government (treasury department) issues national debt, then central bank purchase the debt with paper money that they printed (or create deposits on the government account in the central bank). So the source of money is actually the debt of national government, which is actually backed by national credit with the calculated authorities and capitals (such as army and weapon).&lt;/p&gt;
&lt;p&gt;The problem with the credit based currency is the opposite of the gold based currency, the inflation. As mentioned before, the currency inflation is supposed to be aligned with the economic growth, but credit based currency has a tendency of over inflation.&lt;/p&gt;
&lt;p&gt;so it appears that purely credit based currency does not work very well either, then what will be the future of fiat?&lt;/p&gt;
&lt;p&gt;I’m thinking maybe a money that use BTC as anchor. I.e. a balance sheet that has 20% BTC and 80% credit based asset on its left side. The presence of BTC on balance sheet would limit the inflation. Countries will have their own mining farms to yield BTC, whose distribution will not be limited by geographic like gold did. Isn’t it an appealing future?&lt;/p&gt;
&lt;p&gt;You may argue that we already have such a history like this that use 20% gold and 80% credit for money making. Sure we did, but time has changed right? The history of money is history of human intelligence fighting against the human nature. As only humans ourselves, who konws what’s gonna work and what’s not. :)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Thoughts on Governance]]></title><description><![CDATA[This week’s CW we got a speaker Jian from EthFans talking about the governance mechanisms in blockchain systems.This is the second time for…]]></description><link>https://www.haichaozhu.com//thoughts-on-governance/</link><guid isPermaLink="false">https://www.haichaozhu.com//thoughts-on-governance/</guid><pubDate>Wed, 15 May 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;This week’s CW we got a speaker Jian from &lt;a href=&quot;http://ethfans.org/&quot;&gt;EthFans&lt;/a&gt; talking about the governance mechanisms in blockchain systems.&lt;/p&gt;
&lt;p&gt;This is the second time for Jian to talk about this. There’s a &lt;a href=&quot;https://ethfans.org/ajian1984/articles/36261&quot;&gt;recap&lt;/a&gt; online for his last talk on this. &lt;/p&gt;
&lt;p&gt;Here are some points we have been talked about.&lt;/p&gt;
&lt;h2&gt;On-China Governance.&lt;/h2&gt;
&lt;p&gt;Pure on-Chain governance is a bad idea. The idea is that basically instead of letting the block producers to determine what should be the state stored on-chain and how should the chain works, on-chain governance mechanism (e.g. Tezos) suggests that we should have another voting mechanism implemented on-chain that let people vote for the governance result with their voting tokens. This is a bad idea as it tends to take the governance power away from the block producers (BP). BPs are competitors to each other as they want to fight for the right of producing blocks, so it is nature and healthy for them to vote for the governance of the blockchain system. However, if we have another mechanism that give the power of voting to someone else, these may not necessarily have the competitor relationship to each other.&lt;/p&gt;
&lt;h2&gt;What is the Goal for a Governance Mechanism?&lt;/h2&gt;
&lt;p&gt;So a lot of people are talking about it is very important for public blockchain to have a governance mechanism, but not a lot have explained why. It would make sense if we want to design something to solve a specific problem. However when it comes to governance, I think we have no idea what is the problem we are trying to solve here.&lt;/p&gt;
&lt;p&gt;Some people may argue that fork is bad, and we should use governance to avoid fork. Some may think that it’s too hard to update the public blockchain system, so we need an explicit flow for making changes to the blockchain system.&lt;/p&gt;
&lt;p&gt;The problem here is that bad and good are always a matter of perspective. When a fork happens, it definitely mean that someone is gonna be happy for this fork to happen. Because if no one is happy about doing a fork, then there will be no fork in the first place. Same to the upgrading a public blockchain system.&lt;/p&gt;
&lt;p&gt;But making people happy is still a good starting point for thinking about what is the objective of a governance mechanism. The existence of government is also for making every person governed by them happy. At least this is what a government may claim. &lt;/p&gt;
&lt;p&gt;So if we make the objective of designing a governance mechanism be making every user of a public blockchain happy. Then maybe we can refer to &lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E6%AD%A3%E4%B9%89%E8%AE%BA&quot;&gt;A Theory of Justice&lt;/a&gt; from John Rawls. This basic idea in it is that to bring justice to the society, we should emphasize on freedom of choice. This means that everyone should have the freedom to make their own choice.&lt;/p&gt;
&lt;p&gt;I personally agree with Rawls on this. In a public blockchain system, we should let every user to have the freedom to make choice for every transactions or even the future development direction of this public blockchain system.&lt;/p&gt;
&lt;p&gt;Although in this process, some people may have more vote than others because they have more accumulated capitals that can be converted into votes, this should not obey the theory of justice. Some may have more willingness to vote, and some may just don’t give a shit about how this system works.&lt;/p&gt;
&lt;p&gt;According to the theory of justice, all of these does not matter because all of them have been given the freedom of choice. So even if some of them may still complaint about the final result, there’s nothing more we can optimize here.&lt;/p&gt;
&lt;h2&gt;Let Great People have More Votes&lt;/h2&gt;
&lt;p&gt;Someone from the discussion mentioned an idea of making a reputation system to let better people have more votes for governance. I personally think this is neither necessary nor easy to do.&lt;/p&gt;
&lt;p&gt;In my argument, people that have some good attributes or properties should naturally result in a larger position of capitals (averagely speaking). The capital here could be money, or it could be influence. &lt;/p&gt;
&lt;p&gt;These “great” people can then use these capitals to “buy” more votes in a governance. It means that they already have more rights for voting than others. So I don’t think there is a need to give them another layer of weighting, according to the same properties and attributes.&lt;/p&gt;
&lt;p&gt;It is also hard to build such a system. If this system has some rules defined by humans, then some humans could definitely figure out the rules and optimize themselves according to it. &lt;/p&gt;
&lt;p&gt;So AI based reputation systems here would be an appealing solution. But I don’t know how would that goes.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Post Template]]></title><description><![CDATA[This is a post emplate.You will not see this post on the website as its  is set to .The website needs at least one post to have  and…]]></description><link>https://www.haichaozhu.com//post-template/</link><guid isPermaLink="false">https://www.haichaozhu.com//post-template/</guid><pubDate>Thu, 11 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;This is a post emplate.&lt;/p&gt;
&lt;p&gt;You will not see this post on the website as its &lt;code class=&quot;language-text&quot;&gt;status&lt;/code&gt; is set to &lt;code class=&quot;language-text&quot;&gt;draft&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The website needs at least one post to have &lt;code class=&quot;language-text&quot;&gt;description&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;status&lt;/code&gt; attributes, otherwise there will be errors.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[公链 Token 经济模型的可持续发展性]]></title><description><![CDATA[经济模型的主语是公链 Token，而不是公链。作为货物或货币的 Token 才有经济模型，而链本身只是实现了共识。一个公链，它既为 Token 服务（e.g. 记录账本），又被 Token 所服务着（e.g. 激励矿工）。这篇文章就是想讲讲公链本身是如何被 Token…]]></description><link>https://www.haichaozhu.com//公链 Token 经济模型的可持续发展性/</link><guid isPermaLink="false">https://www.haichaozhu.com//公链 Token 经济模型的可持续发展性/</guid><pubDate>Thu, 11 Apr 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;经济模型的主语是公链 Token，而不是公链。作为货物或货币的 Token 才有经济模型，而链本身只是实现了共识。一个公链，它既为 Token 服务（e.g. 记录账本），又被 Token 所服务着（e.g. 激励矿工）。&lt;/p&gt;
&lt;p&gt;这篇文章就是想讲讲公链本身是如何被 Token 所服务的，而作为 Layer1 的公链有需要拥有怎样的经济模型的 Token 来为其服务，才能实现可持续发展。&lt;/p&gt;
&lt;h2&gt;公链上的 Token 对公链的作用&lt;/h2&gt;
&lt;p&gt;这是公链 Token 的第一个作用，是作为买卖公链系统资源的通货，&lt;/p&gt;
&lt;p&gt;首先定义下什么是公链。不同的人对公链这个概念可能有不同的定义，我这里只说一下我这篇文章对公链的定义。公链的”公”体现在两个方面，一是任何人都可以加入一个公链系统，成为公链的服务提供商；二是任何人也都可以使用公链提供的服务，要么基于这些服务进行开发，要么直接消费这些服务。&lt;/p&gt;
&lt;p&gt;这样的定义下我们可以发现，在每一个区块链系统内，都会存在着一个双边市场。市场的买方是区块链应用的开发者和使用者，而市场的卖方是支撑区块链系统，并且为区块链应用提供资源的服务提供者（矿工和全节点）。&lt;/p&gt;
&lt;p&gt;而 Token （原生的）在这个市场内就起到了一个类似货币的作用。它充当了”公链系统资源”这个物品的价值尺度和交换媒介：矿工和节点付出资源，获得 Token；用户和开发者消耗资源，付出 Token。&lt;/p&gt;
&lt;p&gt;“公链系统资源”可以进一步被分为计算，带宽和存储这三种资源。一般来说，这三种资源均以原生 Token 定价（如比特币）；有时也会用另一种 Token 作为这些资源的价值尺度（如 EOS 中的 RAM，CPU 和 NET）。&lt;/p&gt;
&lt;p&gt;借助 Token，买卖双方会进行直接和间接的两种交易。直接的方式，是用户在发送交易到区块链时，直接付手续费给矿工方；间接的方式是通过 Token 的增发和销毁。增发意味着对所有持币人进行收税，因为增加的 token 量会稀释他们手中的币的价值；相反销毁币意味着对所有持币人进行分红，因为减少 token 的数量会让他们手中的币更稀有，也就更值钱。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“类似货币”意味着它不是货币。货币是一种性质，它是个形容词。如果某个东西具有价格尺度 （Unit of Account），交换媒介（Medium of Exchange）和价值存储（Store of Value）这三种货币性，为了说着顺口，我们一般就可以称它为一种货币。对于公链 Token，一方面它可能并不完全具备这三种性质，另一方面它只服务于一个很小的市场，所以我个人认为它本身并不是我们传统意义上的货币。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公链的 Token 的另一个作用是维护公链系统安全性。&lt;/p&gt;
&lt;p&gt;一般来说，公链的安全性是指它防止链上数据被篡改的能力。篡改链上数据一般需要通过攻击者自行构建一个区块，其中包含对自己有利的交易，并尝试让这个区块被全网所有节点所接受。一个经典的例子就是所谓的 51% 攻击（或者叫女巫攻击）。&lt;/p&gt;
&lt;p&gt;我们可以通过计算这类攻击的成本和收益，来衡量一个公链系统抗衡这类攻击的能力。只有当攻击的收益大于攻击成本，且攻击成本可以被达到时，攻击才会发生，反之攻击则不会发生。再拿比特币举个例，攻击比特币的流程是：首先集结足够算力，然后构造一笔给自己无中生有许多比特币的交易，接着发起攻击，并在产生流动性危机前在市场上将这些币抛售掉。这个过程中，攻击比特币的成本是成功攻击所需要的总算力；攻击成功后获得的收益是卖币能获得的总金额。这种情况下，降低攻击收益就不是一个很好的抗攻击策略了，因为收益比较难以衡量并且不可控。这样的话就只剩下增加攻击成本这条路了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;51% 攻击是概率性攻击。拥有一半以上算力对攻击成功来说，既不是充分条件也不是必要条件。就算你的算力再小，只要坚持不懈，说不定总有一天会成功的；就算你的算力再大，还是可能永远不成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比特币正是通过奖励矿工 Token 的方式来吸引更多的算力，从而增加系统的攻击成本，从而提供系统的安全性。同时，比特币的价值会影响矿工的挖矿意愿，当币价越高，就会有越多的矿工来挖矿，贡献更多的哈希算力。所以，就可以得到这样的一个结论：PoW 公链的 Token 价值越高，公链的安全性越好；反之，安全性就会出现问题。&lt;/p&gt;
&lt;p&gt;总结一下，公链的 Token 有两个作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为买卖公链系统资源的通货&lt;/li&gt;
&lt;li&gt;维护公链的系统安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面所说的 Token 均指公链的原生 Token，智能合约平台上用户自行发行的 Token （UDT, User Defined Token）会在下一节引入。&lt;/p&gt;
&lt;h2&gt;公链经济模型的分析框架&lt;/h2&gt;
&lt;p&gt;这里提出的分析框架的意义，是在于研究怎样的公链 Token 能够更好的为公链提供服务，能为公链系统的可持续的发展提供积极的意义。&lt;/p&gt;
&lt;p&gt;到了这里，公链又要分为两种：第一种是链上只有一种 Token，即链的原生 Token 的链；第二种是支持智能合约功能的公链，这种公链可以作为一个平台，让用户和开发者自己在上面发行 UDT。&lt;/p&gt;
&lt;p&gt;Token 的经济价值将来源于 Token 自身的效用。&lt;/p&gt;
&lt;p&gt;这里的效用是指除了上一节中所描述的，Token 对于公链自身的功能以外的，对外所提供的功能。比如比特币的 Token 的功能性，是作为一个点对点的支付工具，用户可以使用它作为一个通货来买卖货物。&lt;/p&gt;
&lt;p&gt;简单来说，当用户对某个 Token 的功能的需求越高，Token 的内生价值也就越高。这里的原因可以用简单的微观经济学来解释：当一个商品的需求增大时，它的需求曲线会上移，那在供给不变的情况下（大部分货币的供给不随需求改变），价格就会升高。（我这里混淆了价格和价值，假设价值完全由其价格来衡量）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所以某种程度上一个 Token 就是一个产品。它所实现的功能完成度越好，越能满足用户的需求，这个 Token 就越有意义。有意思的是我正在写这个文章的这个时间点是北京时间4月2日上午，BTC 刚刚迎来一波暴涨，然后现在正在往回跌。推特上很多人对此非常兴奋，觉得这是利好。但看了我的分析，我希望你能理解，这种幅度的价格震荡对于 BTC 作为一个支付工具来说是多么大的一个利空。这只会让更少的用户愿意来使用 BTC，它的价值也会因此受损。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于上述的第一种公链，即只有原生 Token 的公链，分析起来会相对简单。当用户群体对某个公链的 Token 给他们所提供的功能有足够的需求时，这个 Token 本身就会拥有足够强的流动性，能够很好的在公链系统内充当通货；同时，Token 的价值也会更高，所以公链的安全性也会更好。这个公链也就更有可能持续的发展下去。相反如果用户对这个 Token 没有需求，那它作为交换媒介的功能也就会更弱，公链的安全性也会受到影响，&lt;/p&gt;
&lt;p&gt;对于第二种，能够支持 UDT 的公链来说，由于有 UDT 的存在，情况会相对复杂，下面具体解释说明这其中需要解决的两个关键问题。&lt;/p&gt;
&lt;h3&gt;公地悲剧问题&lt;/h3&gt;
&lt;p&gt;经济学里有一个经典的故事叫做公地悲剧（ The Tragedy of Common）。公共草地上，有一群牧羊人。每一个牧羊人都想要多获利一些，所以某个牧羊人就带了大量的羊来放牧，虽然他知道过度放牧，草地可能会承受不住。但他依然获利了，而后所有的牧羊人都跟进，所以草地牧草耗竭，悲剧因而发生了。&lt;/p&gt;
&lt;p&gt;这个问题对于智能合约公链来说同样存在：公链就像是”草地”，而”羊”就是公链上发行的 UDT，UDT 的发行者和使用者们，就是故事中的”牧羊人”。&lt;/p&gt;
&lt;p&gt;在公链上发行和使用 UDT 时，都会占用公链的资源，每一个用户都想更多的占有这些资源来满足自己的需求。即使他们知道这会带来不好的影响，但为了自身利益依然会继续占有这些资源，最终导致公链的运行成本大幅增加，导致去中心化特性枯竭。&lt;/p&gt;
&lt;p&gt;这里更准确的说，“草地”应该特指公链上的存储资源。由于现在的大多数公链平台，都会对计算和带宽资源通过交易手续费进行收费，所以这部分的资源实际上不算是”公地”，而是市场内部的商品。但是存储资源却很少有公链考虑。另外，与计算和带宽不同的是，存储资源的消耗是与时间维度相关的。随着存储时间饿的增长，即使占用的存储空间不变，消耗的”存储资源总量”是不断增长的。就好比租一个房子，租的时间越长，需要付的费就越多。&lt;/p&gt;
&lt;p&gt;所以公链系统中存储资源的公地悲剧问题，是在分析智能合约公链经济模型时需要考虑的一个关键问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在以太坊上，计算和带宽资源会由用户通过手续费来支付，但是存储资源的费用是没有被恰当的计算的。手续费只需要复一次，而存储资源的占用是永久的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;公地悲剧既然是在经济学的研究中提出的问题，答案自然也可以在经济学研究中找到。解决方案简单来说，就是将公地进行市场内部化，让公地这个公共资源明码标价，成为市场内的一部分。让它像计算和带宽资源一样，谁要想用，就付 Token 出来。&lt;/p&gt;
&lt;p&gt;以太坊社区最近就在考虑处理以太坊的公地悲剧问题。社区提出了 EIP103，准备在 Serenity 阶段实施 Storage Rent 机制。即对占用状态存储的用户按占用时长收取租金。这个方案的提出代表着社区已经开始关注到了这个问题，这意味任何一个新的公链系统，都需要在自己的系统设计中对这个问题作出回应。&lt;/p&gt;
&lt;h3&gt;价值捕获问题&lt;/h3&gt;
&lt;p&gt;上面在分析第一种类似比特币的公链系统时提到了，只要这种公链的 Token 对外的功能性方面有着良好的产品设计，能够切实满足用户需求，吸引用户使用，那这个公链的安全性就可以得到保障，因此也可以持续的发展下去。&lt;/p&gt;
&lt;p&gt;对于支持智能合约的公链平台来说，UDT 的存在意味着会有各种有才华的开发者们在平台上开发出具有不同功能的 UDT 产品，这些产品同样会吸引用户使用。&lt;/p&gt;
&lt;p&gt;但这里的问题是，对于原生 token 的需求可以转换成公链的安全性，而对于 UDT 的需求是否能转换成安全性呢？比如现在以太坊上有海量的 ERC20 代币（以下简称 UDT），这些代币的对应的需求基本上就是交易，就是炒。理论上在交易这些代币的时候是需要用以太币来支付手续费的，这样对于炒这些 UDT 的需求就会转化成对原生代币以太币的需求，以太坊系统的安全性也会得到保障。但实际上，这些代币的交易都发生在链下的交易所里面，只有在提币，充币或者 OTC 的时候才会产生链上的交易。在这样的情况下，其实只有一部分的 UDT 代币需求会转化成对以太币的需求。如果随着该 UDT 的价值增高，而对应的转化到以太坊的需求的比例没有对应增长的话，那可能会出现该资产的价值超过以太币的价值的时候。这时候的以太坊就已经没有办法以足够的安全性来保管这个资产了。&lt;/p&gt;
&lt;p&gt;这个需求转化的过程也可以叫价值捕获，智能合约平台的原生代币能否成功捕获 UDT 的价值，就成了一个影响平台稳定性的关键因素。&lt;/p&gt;
&lt;h2&gt;总结一下&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;公链是双边市场&lt;/li&gt;
&lt;li&gt;支持发行 UDT 的公链相比于只有一种原生代币的公链将面临更多的挑战&lt;/li&gt;
&lt;li&gt;公链代币的经济模型机制设计需要通过外部性内在化，确保消除公链市场中的外部性&lt;/li&gt;
&lt;li&gt;智能合约平台的原生代币需要捕获其上面发行的 UDT 的价值&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Blockchain Interoperability Protocols]]></title><description><![CDATA[Blockchains are self-contained systems. They generally do not have any kind of connections with each other, like isolated islands in the…]]></description><link>https://www.haichaozhu.com//blockchain-interoperability-protocols/</link><guid isPermaLink="false">https://www.haichaozhu.com//blockchain-interoperability-protocols/</guid><pubDate>Mon, 17 Dec 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Blockchains are self-contained systems. They generally do not have any kind of connections with each other, like isolated islands in the ocean. It’s not controversial that making different kinds of blockchain systems can interact with each other could introduce many benefits. The next question we might ask is how to find the right protocol design to achieve the expected interoperability applications, and I hope this post can help you to find the answer to it. &lt;/p&gt;
&lt;p&gt;This post will introduce different protocols for realizing interoperability as well as some problems that needs to be considered when utilizing them. The discussion here only considers the interaction between two blockchain systems. Interactions with other type of systems are not included in this post, as they should be discussed case by case. Also, the discussion will only be carried on a protocol level. Higher level topics, such as user experience, price discovery and order matching are not covered in this post.&lt;/p&gt;
&lt;h2&gt;What Exactly is Interoperability?&lt;/h2&gt;
&lt;p&gt;To answer this question, we can start by looking at several potential blockchain interoperability applications, and try to find the shared problems that need to be solved:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Asset Transfer / Portable Asset:&lt;/strong&gt; Alice transfers some of her coin from chainA to chainB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Asset Exchanges / Atomic Swaps:&lt;/strong&gt; Alice uses coinA on chainA in exchange for Bob’s coinB on chainB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cross-Chain Contract:&lt;/strong&gt; Alice deposits some coinA into a contract on ChainA and get some coinB on chainB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Above describes some applications from a user’s perspective, while the actual operations take place in the blockchain systems could be something like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Asset Transfer / Portable Asset:&lt;/strong&gt;
Event X: Alice sends some coins to a black-hole address on chainA (to destroy or burn the coins)
Event Y: some coins are created (minted) and sent to Alice’s address on chainB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Asset Exchanges / Atomic Swaps:&lt;/strong&gt;
Event X: Alice transfers coinA to Bob on chainA
Event Y: Bob transfers coinB to Alice on chainB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cross-Chain Contract:&lt;/strong&gt;
Event X: Alice transfers some coins to a contract on chainA
Event Y: some coins are created and sent to Alice on chainB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;To generalize the applications above:&lt;/strong&gt;
Event X: a transaction happens on chainA
Event Y: a transaction happens on chainB. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All the event X and Y mentioned above should happen simultaneously or not happen at all (or one of them can be reverted or canceled when the other one do not happen according to a preliminary agreement). For convenience, the notion chainA, chainB, event X, event Y are used all the way through this post. Please consider them as representing the same meaning as shown above by default.&lt;/p&gt;
&lt;p&gt;By examining the generalized form of interoperability operation (the last set of event in the list above), hopefully we can arrive at the following conclusion: the essence of realizing interoperability is to design a protocol that can make sure when event X happens on chainA, chainB is able to know and verify this fact, and an event Y on chainB is enforced. To be more accurate, the word “happens” here should be replaced by the word “finalize”, which means a transaction has been agreed on blockchain by most of the validators or operators (51% or 2/3, depending on the consensus mechanism), and it has reached a state that there is a very low probability that this transaction can be altered.&lt;/p&gt;
&lt;p&gt;It should be noticed that this generalized form of interoperation is only the most basic atomic elements, and more complex protocols and applications can be built on top of it.&lt;/p&gt;
&lt;h2&gt;Notary&lt;/h2&gt;
&lt;p&gt;One intuitive method is to let a third-party notary serve as a “connector” between two chains. Here we introduce a typical procedure of a notary based interoperation scheme:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On chainB, event Y is registered along with a trigger that can be pulled by the notary&lt;/li&gt;
&lt;li&gt;On chainA, event X is finalized and the notary witnessed and verified this fact&lt;/li&gt;
&lt;li&gt;The notary trigger the event Y on chainB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The trigger mentioned above could be instantiated in different forms. On a turing-complete blockchain, this can be implemented via a smart contract that verifies the signature of the proof. In the case that the smart contract on chainB can interpret proofs from chainA directly, the smart contract can also be triggered by the proof of event X directly, without the need of notary. This type of contract is called a relay contract, and the details are discussed in the next section. Alternatively, the registration and trigger can also be created &lt;a href=&quot;https://interledger.org/interledger.pdf&quot;&gt;using an escrow account&lt;/a&gt;. (e.g. the coin are transferred into an escrow account and transferred out later when triggered) The escrow account can be controlled by the notary, or controlled by a fourth-party that would conduct the transaction when the notary tells them to do so or when some sort of proofs are presented. &lt;/p&gt;
&lt;p&gt;The notary here can be one entity or a set of entities (a federation) that is trusted by the parties involved in this specific interoperation. In the case of federation-as-notary, different entities can also be united using a blockchain system (in the practice, it should be one that is based on PBFT, in order to reach instant-finality). Furthermore, the trust towards the notary can be derived from some existing trusted systems, such as a bank, or a highly secured and decentralized public blockchain, by designing a staking and slashing mechanism. (For example, to be a notary, one needs to stake a certain amount of coins on a public blockchain, along with a contract that describes a set of rules for being a notary. In the case of this notary acting maliciously, some “fisherman” can submit proof of this notary’s malicious activities to this contract, and get this notary punished by a penalizing their staked coins. These fishermen in turn get rewarded from these penalty. In this way, the “fisherman” is incentivized to oversee the notaries, and the notaries are incentivized to be benevolent.)&lt;/p&gt;
&lt;p&gt;Upon the registration of event Y, there should be an implementation of some sort of “cancel” or “abort” method, which can revert the registration process (e.g. send the coins back to the user from escrow account). This is a way of protecting against the case when the subsequent procedures are not conducted properly. In Additional, a timeout should also be enforced, in case the user are not available to manually call the  cancel method. Detail specifications should be designed according to the particular application concerned.&lt;/p&gt;
&lt;p&gt;There is also the option of letting user or some other third-party server to get a signature from notary, and send this signature to chainB to trigger the event Y, instead of having the notary to send the proof to chainB directly. A later section discusses The question that who the person to relay the message should be.&lt;/p&gt;
&lt;h2&gt;Relay Contract&lt;/h2&gt;
&lt;p&gt;The term “relay contract” here refers to a contract deployed on chainB that can verify the proof about a transaction’s finality on chainA, where the proof is generated on chainA directly. This can be seen as a special case of notary scheme where the operator/miner/validator of chainA plays the role as notary. Their original duty is to verify each of the transaction’s validity so that the blockchain system is maintained. The trick here is that there are some kinds of proofs generated from these blockchain-keepers’ routine verification works, and these proofs can be verified by the relay contract directly, so that the interoperation can be achieved without any intermediaries. Here’s a typical procedure of a relay contract based interoperation scheme:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On chainB, the relay contract is deployed &lt;/li&gt;
&lt;li&gt;On chainA, event X is finalized and a proof is sent to and verified by the relay contract&lt;/li&gt;
&lt;li&gt;The event Y is triggered by the relay contract on chainB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most commonly used proof and verification process for relay contract is the SPV (Simple Payment Verification) introduced in Bitcoin, where SPV is used to enable light client node to verify transactions without having the full history of transaction data and UTXO set as does a full node. The basic idea is to let light client node only store the header of each of the blocks on chain, and when there’s a need to verify a transaction, a light client node would request a Merkle Proof from a full node. Essentially a Merkle proof is a Merkle Path whereby combining with block header, one can verify if a specific transaction is included in this block. (&lt;a href=&quot;https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch09.asciidoc#merkle-trees&quot;&gt;See&lt;/a&gt;&lt;a href=&quot;https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch09.asciidoc#merkle-trees&quot;&gt;here&lt;/a&gt; for Merkle Trees) &lt;/p&gt;
&lt;p&gt;In the case that chainA has a relatively long time-to-finality period (e.g. bitcoin needs 6 blocks for transaction finality), one thing should be noticed is that chainB will need the information about whether the block that packed this transaction has a big enough depth. (Block depth refers to the height difference between this block and the latest block) This will require the relay contract to have data about these extra block headers (6 block headers in bitcoin’s case and around 100 in Ethereum’s case). One of the potential problems here is that processing the data of 100 block headers signature may exceeds the capability of a contract (i.e. exceeding the block gas limits). So sometimes chainB would need to synchronize all the block headers from the genesis block, and verify each of the block along with the blockchain growing. In this case, it is often said that chainB is a “sidechain” to chainA. &lt;/p&gt;
&lt;p&gt;In addition, another potential weakness is the market volatility problem. In the case when Alice wants to trade some ETH for BTC from Bob, during the period of time when Alice is waiting for her transaction to be finalized (around one hour in Bitcoin’s case), there might have been a drastic change in terms of the exchange rate on the open trading market. This market volatility might influence Alice’s (or Bob’s) willingness to conduct this trade and eventually keep the trade from happening.&lt;/p&gt;
&lt;p&gt;It also should be noticed that this approach only works on a turing-complete blockchain, in order to implement precautions against some cheat or attack patterns. One example is the “race condition attack”: in the use case of atomic swap of BTC and ETH between Bob and Alice, Bob would first deploy a relay contract on Ethereum that says whoever send 1 BTC to my address on Bitcoin can claim 1 ETH from this contract, then he could ask Alice to send 1 BTC to his address and at the same time, he send himself 1 BTC as well, then he can use the proof of his transaction to claim the 1 ETH from the relay contract. In some cases he would succeed and leave Alice with nothing and himself with 1 extra BTC. This kind of attack could be prevented by appending a script to Bob’s address on Bitcoin that says all the transactions will be ignored except only the first one. However, with Bitcoin’s existing script mechanism, it is not feasible to implement this on Bitcoin in anyway, while a mechanism like this can be easily implemented on a turing-complete blockchain.&lt;/p&gt;
&lt;p&gt;Even with turing-completeness, there’s still a chance that two turing-complete blockchain can not have interoperability with each other. This happens when two blockchains have different selections on their signature functions, serialization algorithms and hash functions. For example, an EVM based blockchain system may only have a fixed set of cryptographic functions available. When chainA and chainB have two different sets of cryptographic functions, it may cost an unacceptable amount of gas for chainA’s EVM to interpret the proof from chainB. This problem could be solved by a blockchain with a powerful enough VM on which all kinds of cryptographic primitive functions can run, such as the &lt;a href=&quot;https://medium.com/nervosnetwork/an-introduction-to-ckb-vm-9d95678a7757&quot;&gt;RISC-V based CKB-VM&lt;/a&gt; used in Nervos CKB.&lt;/p&gt;
&lt;p&gt;[Hash-Locking Diagrams]&lt;/p&gt;
&lt;h2&gt;Hash-Locking&lt;/h2&gt;
&lt;p&gt;Hash-locking is an ad-hoc technique for conducting atomic swap, which also works in a cross-chain scenario. Here’s a typical procedure for a hash-locking based interoperation scheme:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alice generates a key and a lock, and sends the lock to Bob.&lt;/li&gt;
&lt;li&gt;Alice deploy a contract and lock it on chainA says whoever successfully unlocks this contract can claim 1 coinA.&lt;/li&gt;
&lt;li&gt;Bob deploy a contract and lock it on chainB says whoever successfully unlocks this contract can claim 1 coinB.
(now we have two contracts on two chains with the same lock, whose key is known by Alice but not Bob)&lt;/li&gt;
&lt;li&gt;Alice claim the coinB from Bob’s contract on chainB. This process reveals the key to Bob.&lt;/li&gt;
&lt;li&gt;Bob claim the coinA from Alice’s contract on chainA.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here, the key and lock is usually implemented using a hash function: lock = hash (key). &lt;/p&gt;
&lt;p&gt;In this scheme, one thing that has to be noticed is the timeout setting for these two contracts. Normally timeout setting is for preventing coins from being locked in a contract forever, as stated in an earlier section. However in the hash-locking case, it is Alice that has the key at first, and this gives her some privileges that potentially she can make use of the network latency or some other environment parameters to cheat Bob. That is why when setting timeout parameters for the contract, Bob’s contract should have a longer period than Alice’s contract, so that he will have enough time to handle all kinds of situations. Bob’s contract timeout period usually should be double of Alice’s (i.e. Alice’s contract has x seconds to claim and Bob’s has 2x seconds to claim). On the other hand, due to this time-out setting, hash-locking scheme based interoperation could also be influenced by the market volatility problem mentioned above.&lt;/p&gt;
&lt;h2&gt;Additional Considerations&lt;/h2&gt;
&lt;p&gt;One of the issues that is overlooked by above discussions is that who should make the effort to pass messages (proofs) from chainA to chainB. Options include Users, Notary, Chain Miners/Validators/Operators or a Third-Party. However the thing is that the proof we are talking about here are all cryptographically signed by the proof creator. So it is sufficient to argue that the role of message relayer is not relevant to the safety of the protocol. In another aspect, the choice of this role could have significant implications on the UX and system implementation. (e.g. message relayer might charge a fee for relaying messages) &lt;/p&gt;
&lt;p&gt;Once the interoperability is achieved between two blockchain systems, there might be an emerging challenge that the difficulty level for security analysis is largely increased. First of all, the security model of both blockchain systems should be analyzed respectively. This may include trust assumptions like the liveness of blockchain or the Byzantine fault tolerance of the blockchain. Moreover, since the interoperation link is established, an attack towards chainA would very likely impact chainB, and an incident on chainB could also affect chainA. This would require a security model to be formed by considering the two blockchain systems as an integrated system, instead of two separated systems, and thus creates more challenge.&lt;/p&gt;
&lt;p&gt;[Multichain Diagrams, two topologies]&lt;/p&gt;
&lt;h2&gt;Multi-Chain Interoperability&lt;/h2&gt;
&lt;p&gt;So far this article has discussed the interoperability between two blockchains, while in the multi-chain scenarios, additional issues might arise as well. One of the major problem is how we should choose the network topology. Another one is how we identify the blockchains.&lt;/p&gt;
&lt;p&gt;One of the options to form a network of multiple blockchains for interoperation is to let every two of them connect with each other. This will indeed require a lot of connections to be established and thus seems not effective. However, in the case that all involved blockchains have the identical constructs and implementations (e.g. consortium blockchains deployed for different industries), they all can share the same set of protocol to interact with each other, and thus all of them can read messages from one another. Also the security model would be relatively easier to form. As in the scenario that has many blockchains with different constructs, multiple set of protocols would be needed to exist, and it’s nearly impossible to successfully implement them on each of the blockchains, due to the complexity and the amount of effort needed.&lt;/p&gt;
&lt;p&gt;Another option is to have a hub-and-spoke network. This has been adopted by &lt;a href=&quot;https://cosmos.network/docs/resources/whitepaper.html#inter-blockchain-communication-ibc&quot;&gt;Cosmos&lt;/a&gt; and &lt;a href=&quot;https://polkadot.network/&quot;&gt;Polkadot&lt;/a&gt;, both of which have an independent blockchain as a centralized hub or bridge (Comos Hub / Relay Chain). When users on two blockchains in this network want to transfer assets, they will need to first transfer their assets to the hub chain from its origin chain, and then transfer it from the hub chain to the target chain. In the design of Cosmos and Polkadot, they use relay contract based mechanism for interoperability between the hub and their own designed application chains (Zones / Parachains). For the other blockchains, they make use of a set of proxy chains as notary for their interoperation with the hub. In this topology, it is obvious that the security of the hub chain is crucial for the whole security model, and thus deserve extra considerations in the overall protocol design.&lt;/p&gt;
&lt;p&gt;The second problem mentioned above is how to identify the blockchains. This is needed because when a blockchain receives a proof, it needs to verify the match between the proof and the blockchain identity claimed in the proof. This is usually achieved by a &lt;code class=&quot;language-text&quot;&gt;chainID&lt;/code&gt; attributes that comes with the proof. The problem is how  the registry of &lt;code class=&quot;language-text&quot;&gt;chainID&lt;/code&gt; is done. In a local hub-and-spoke network with only one hub, it could be registered on the hub chain for it should be most secured blockchain in this network. However in a bigger public network, a secured and decentralized public blockchain would be the first choice to do the registry. As a large scale interoperable blockchain network is yet to come, this topic has not been not widely discussed so far. &lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As there are still many new blockchain systems popping up, and each of them may have very different designs, it would be very difficult to have a generic protocol that can “rule them all”, in terms of enabling interoperability between these blockchain systems. Therefore it is reasonable to make the argument that enabling interoperability for blockchains should be an application-driven process. Different approaches may be suitable for different applications in different scenarios. Once the actual use case is settled, I hope this post can help designers who are seeking interoperability to find the protocol that matches their needs the best. The discussion here does not hope to cover the full spectrum of blockchain interoperability. Comments are more than welcomed in order to make this post more comprehensive.&lt;/p&gt;
&lt;hr&gt;</content:encoded></item></channel></rss>